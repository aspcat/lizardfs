#pragma once

#include <stdint.h>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <vector>

#include "common/exception.h"
#include "common/io_limits_config_loader.h"

class IoLimitsDatabase {
public:
	typedef void* ClientId;
	typedef std::string GroupId;

	// general exception
	class Exception : public ::Exception {
	public:
		Exception(const std::string& message) : ::Exception(message) {}
	};
	// attempt to perform operation on unknown client
	class InvalidClientIdException : public Exception {
	public:
		InvalidClientIdException() : Exception("invalid client id") {}
	};
	// attempt to register already registered client
	class ClientExistsException : public Exception {
	public:
		ClientExistsException() : Exception("client already registered") {}
	};
	// attempt to perform operation on unknown group
	class InvalidGroupIdException : public Exception {
	public:
		InvalidGroupIdException() : Exception("invalid group id") {}
	};

	// default constructor, all limits are zero
	IoLimitsDatabase() {}

	// set limits (as generated by IoLimitsConfigLoader)
	//
	// all limits in bytes per second
	//
	// changes take effect when clients try to alter their limits
	// (no support for master-initiated limit renegotiation)
	void setLimits(const IoLimitsConfigLoader::LimitsMap& limits);

	// get a list of all groups
	std::vector<std::string> getGroups() const;

	// add / remove a client
	void addClient(ClientId id);
	void removeClient(ClientId id);

	// try to satisfy client's request to change limit in given I/O group, return actual limit
	uint64_t setAllocation(ClientId clientId, const GroupId& groupId, const uint64_t goal);
	// get client's limit in given I/O group
	uint64_t getAllocation(ClientId clientId, const GroupId& groupId);

private:
	typedef uint64_t Allocation;
	typedef std::unordered_map<ClientId, Allocation> Allocations;

	struct GroupState {
		uint64_t limit;
		uint64_t allocated;
		Allocations allocations;
	};

	typedef std::unordered_set<ClientId> Clients;
	typedef std::map<GroupId, GroupState> Groups;

	GroupState& getGroup(const GroupId& id);
	Allocation& getAllocation(GroupState& group, ClientId id);

	Clients clients_;
	Groups groups_;
};
